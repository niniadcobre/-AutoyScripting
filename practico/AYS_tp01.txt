----------------------------------
TP01 - Automatización y scripting 
FAI - TUASSL
----------------------------------

-----------------------------------------------------------------------------
MANUAL DE REFERENCIA: "BEGINNING LINUX PROGRAMMING"
-----------------------------------------------------------------------------

1. ¿Dónde se encuentra bash ubicado en su sistema? 
   ¿De qué tipo es el archivo? 
   ¿Cuáles son sus permisos?

2. ¿De qué tipo de archivo, son todos los shells disponibles en su sistema?
   (responda utilizando comandos para verificar su respuesta)

3. a) ¿Cómo saber cuál es el shell que estoy ejecutando al abrir una terminal o
      cuando me conecto a una consola?
   b) ¿Dónde se define el shell predeterminado para un usuario? 
   c) ¿Cómo puedo hacer para ejecutar un shell diferente?

4. Obtenga la versión de bash que esta utilizandon. 

5. ¿Cuántos procesos se encuentran en ejecución en el sistema?. Recuerde
   descontar los encabezados si utiliza ps y wc, a menos que use la opción
   apropiada para evitar dicho encabezado ¿Cuál es?. 

6. ¿Qué comando utiliza para mostrar el nombre del host y sólo el nombre 
   del host?  

7. ¿Cómo obtiene ayuda, en la terminal, acerca de las funcionalidades de bash?

8. Indique la diferencia entre info, man y help.
  
-----------------------------------------------------------------------------
Redirección y pipe
LEA LAS PÁGINAS 21 A 23 DEL MANUAL DE REFERENCIA. 
-----------------------------------------------------------------------------

El uso de la redirección y los pipes es fundamental en la construcción de 
scripts ya que, siguiendo la filosofía UNIX, nos permite combinar programas
para construir nuevas funcionalidades. En tal sentido es importante RECORDAR que 
existen tres descriptores de archivos frecuentemente utilizados y redireccionados
dentro de un proceso (programa en ejecución): 

0 Entrada estándar (lo leído por un proceso)  
1 Salida estándar (lo escrito por un proceso durante un funcionamiento normal) 
2 Error estándar (lo escrito por un proceso cuando sucedió algún acontecimiento anormal)

Ejemplo: 
$ read palabra #<- en este caso la entrada estándar se espera desde la terminal. 
ls | wc        #<- en este caso la salida estándar de ls será la entrada estándar de wc. 
                   El error estándar de ambos comandos se dirige a la terminal. 

¿Todos los programas reciben una entrada?


9. Explique el funcionamiento de las siguientes redirecciones. Indique además cuál es 
la entrada, la salida y el error _si lo hubiera_. 

	ls > archivo.txt 
	ls >> archivo.txt 
	ls archivoinexistente.txt > archivo.txt 
	ls archivoinexistente.txt > /dev/null
	ls archivoinexistente.txt > archivo.txt 2>&1
	ls archivoinexistente.txt &> archivo.txt 
	ls archivoinexistente.txt &> /dev/null 
	read palabra < archivocontexto.txt ; echo $palabra

El pipe es un mecanismo que permite vincular la entrada y salida de los procesos. De este
modo lo escrito por un proceso es leído por el siguiente en la cadena de pipes. 

10. Explique el funcionamiento de los siguientes pipes. Indique cómo debiera reemplazar
cada sentencia si no existiera el pipe. 

	du -sh * |sort -h 
	ps -ef |grep root  
	ls -hl |grep root |sort -h -k 5  	
	df -h |grep /dev
	dpkg -l paquetenoexiste |grep -v dpkg  

En los casos que aparece el programa sort, ¿cómo sabemos sobre qué campo de la
salida se produce el ordenamiento? 

-----------------------------------------------------------------------------
OBSERVACIÓN: Filosofía UNIX vs. nuevas tendencias

La sentencias como la siguiente son frecuentes: 

	cat /etc/passwd |sort |uniq

El MISMO resultado se obtiene haciendo:

	sort -u /etc/passwd 

Ambas logran el mismo objetivo, y si bien la última utiliza un solo programa, 
la primera es más representativa de la filosofía UNIX y más portable ya que 
muchos UNIX pueden tener versiones de sort (más puristas) que no reciben 
archivos como argumentos, y sólo trabajan sobre flujos de texto; o pueden no
soportar la opción "-u". Evalúe según el ámbito y sus necesidades puntuales
el uso de una u otra opción. Generalice esta idea al resto de los programas. 
-----------------------------------------------------------------------------

11. Ejecute y explique : seq 5

¿Puede generar una secuencia que comience en el número 22 y termine en el 60?

12. Ejecute y explique : 
   echo {01..100}
   echo {15..25..5}

Nota: ver "Brace Expansion" (Expansión de llaves) - man bash, sección Expansión. 

¿Puede generar una secuencia que comience con 0022 y termine en el 0060?

13. Ejecute y explique: echo soy_{isaac,asimov}_escritor

14. Ejecute y explique : echo {z..a}

¿Puede generar la secuencia de letras desde la B (mayúscula) hasta
la Q?

¿Qué programa hace la expansión de las llaves en los ejercicios 2, 3 y 4?

-----------------------------------------------------------------------------
OBSERVACIÓN: es muy importante prestar atención a cuál es el 
programa que realiza la expansión de metacaracteres*. ¿Lo hace el shell o él 
programa que recibe la entrada? En este sentido, hay programas que aceptan 
el uso de metacaracteres para armar expresiones regulares. Por ejemplo, 

grep '^s.*e' /etc/passwd

Los metacaracteres que se encuentran entre las comillas simples son 
interpretados por grep y no por bash.  

*Se considera metacaracter a aquellos caracteres que tienen un significado no 
literal para el programa que los interpreta. 
-----------------------------------------------------------------------------

15. Ejecute y explique : 

echo "Esta es la salida de mi código a dos lugares distintos" | tee salida.txt

¿Para qué podría ser de utilidad el comando tee dentro de un script?

16. Ejecute y explique : 

seq 10 | xargs -n 2 

Encuentre al menos otros dos usos del programa xargs.  

17. Ejecute y explique :

echo "linux" | tr a-z A-Z 

18. a) Ejecute y explique :
       cat /etc/passwd |cut -f 3 -d:   

    b) ¿Puede listar el ID del usuario y su nombre completo y ordenar la lista
       de manera inversa?
    c) ¿La versión de cut que utiliza soporta trabajar sobre archivos directamente? 

19. Listar los paquetes instalados :

dpkg -l | awk '$1=="ii" {print $2}' 

dpkg -l | grep ii | awk '{print $2}' | sort 

a) ¿Qué diferencias hay entre la primer y segunda sentencia? 
   ¿Cuántos programas se invocan en cada uno?¿Cuál es más exacta?
b) ¿Puede generar los dos listados pero que incluyan la versión del paquete?
c) ¿Por qué se seleccionan aquellos con ii? 

20. Ejecute y explique :

tac /etc/passwd 

¿Conoce algún programa que haga la operación inversa?

21. Ejecute y explique :

cat /etc/passwd |head -20 | tail -1

a) ¿Cuál es el objetivo de la sentencia anterior? 
b) ¿Cuántos programas utiliza?¿Puede hacer esto mismo con menos programas? 
   Generalice la solución para cualquier número de línea. 















23. Lea páginas 31 a 36 del manual de referencia, luego
Ejecute y explique estos casos :

Caso a)

[[ -d /var ]]
echo $?

test -d /var
echo $?


Caso b)

[[ -d /directorio ]]
echo $?

test -d /directorio
echo $?


Caso c)

if [[ -d /var ]] ; then
	echo "El dir existe"
else
	echo "NO existe"
fi


Caso d)

if test -d /var  ; then
	echo "El dir existe"
else
	echo "NO existe"
fi


Caso e)

if test -d /var && [[ -d /etc ]] ; then
	echo "Los dos directorios existen "
else
	echo "Alguno NO existe"
fi


Caso f)

if test -d /var && test -d /directorio ; then
	echo "Los dos directorios existen "
else
	echo "Alguno NO existe"
fi


24. Ejecute y explique :

echo "2 2 2 1 2 1 3 4 5 6 6" | tr " " "\n" | sort | uniq -u

25. Ejecute y explique : 

echo "a b c" > /tmp/uno
echo "d e f" > /tmp/dos
paste /tmp/uno /tmp/dos
