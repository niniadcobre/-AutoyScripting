----------------------------------
TP05 - Automatización y scripting 
Herramientas: find, sed, grep, awk,
cron/at
FAI - TUASSL  
----------------------------------

MANUAL DE REFERENCIA: "BEGINNING LINUX PROGRAMMING"
---------------------------------------------------
NOTA1: Los temas cubiertos en este práctico incluyen los
desarrollados en las páginas 

NOTA2: Cuando los ejercicios pidan modificar código, repita
el bloque a continuación del original y haga las modificaciones.  

NOTA3: Cada vez que modifique el código VERIFIQUE su correcto 
funcionamiento.  

NOTA4: Cuando se pida modificar un script, todas las modificaciones
deben hacerse en simultáneo en la misma versión. 

EJERCITACIÓN:
---------------------------------

0. Comando find. En cada caso indique cuál es el directorio de búsqueda. 
Cuáles son las opciones que afectan toda la operación; las pruebas que 
afectan archivos individuales, y las acciones a realizar. ¿Es necesario 
ser root para ejecutar estos comandos? ¿Siempre será necesario?


  ####        #   ####
 #    #       #  #    #     EVALUAR LA SENTENCIA ANTES DE EJECUTAR
 #    #       #  #    #     PUEDE CAUSAR ESTRAGOS EN SU MAQUINA PERSONAL
 #    #       #  #    #
 #    #  #    #  #    #
  ####    ####    ####

 a) Indique el comando find que cumpla con lo pedido en cada búsqueda. 
     i) Busque archivos en todo el árbol de directorios tal que que 
        pertenezcan a root y tengan permisos 777. 
    ii) Busque archivos de dispositivos (bloques o caractér). 
   iii) Busque archivos regulares finalizados en jpg o JPG, ubicados dentro 
	del directorio home y, liste sus propiedades. 
    iv) Busque archivos que hayan sido modificados hace 1 día.
     v) Busque archivos en todo el árbol de directorios tal que:  
        pertenezcan a root y tengan permisos 777 y, sean scripts. 
    vi) Busque archivos en todo el árbol de directorios tal que:  
        pertenezcan a root; tengan setuid o setgid y, permisos 
        de escritura y lectura para todos, y no sean binarios (ELF). ¿Por qué 
        pueden ser interesantes estos archivos desde el punto de 
        vista de la seguridad?

 b) Describa el alcance de las siguientes búsquedas:
	 i) find . -mmin -5  -ls
	ii) find / -mount \( -nogroup -or -nouser \) -ok rm {} \;
       iii) find /home -size +2G -type f -delete 	
	iv) find /tmp -printf "%p %k %\n"
       
1. Expresiones regulares:  
Una  expresión  regular  es  un  patrón que describe un conjunto de cadenas 
de caracteres. Las expresiones regulares se construyen de forma análoga a 
las expresiones aritméticas, combinando expresiones más pequeñas mediante 
ciertos operadores para formar expresiones complejas. -man grep- 

Las herramientas find, sed, grep, awk y perl utilizan expresiones regulares. 
Sin embargo, cada herramienta puede dar soporte a un cierto tipo de expresiones
regulares y no otros. En cada caso corresponderá analizar cuál es el tipo de
expresiones regulares soportadas y, utilizarlas en consecuencia. Por ejemplo 
en el caso de find, las expresiones regulares utilizadas de manera 
predeterminada son las mismas que provee el software emacs. Sin embargo 
find provee la opción regextype, que nos permite cambiar ese comportamiento, 
y utilizar por ejemplo las mismas expresiones regulares que egrep (grep -E).

Más información: 
http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html

 a) Indique el alcance de las expresiones regulares en cada comando; y el 
    efecto logrado por el comando en general. 

     i) find / -xdev -regextype posix-egrep -iregex '(/usr)?/[s]?bin/.*'
    ii) find / -xdev | egrep '(/usr)?/[s]?bin/.*'
   iii) egrep -n  '\b(\w+)[ ]+\1\b' mitexto.txt
    iv) /sbin/ifconfig  | egrep '\b([[:xdigit:]]{2}:){5}[[:xdigit:]]{2}\b'

Utilizando egrep cree una expresion regular que para las siguientes situaciones: 
3. Uso de awk.  
Awk es un lenguaje de programación orientado al procesamiento de patrones y 
textos. Permite soluciones más generales de las que podemos lograr con sed. 
Sin embargo, existen pocos scripts en el sistema totalmente escritos en este 
lenguaje. Su uso más frecuente es en pequeñas sentencias dentro de scripts
escritos en bash, sh, etc. 

A continuación se indican varias sentencias awk extraídas de scripts del
sistema (findshell |xargs grep awk ). Indique la función que realiza awk 
en cada caso; y el efecto del comando en general. 

 a) AMOUNT=`nc -v -w 120 -l -p $NCPORT | wc -c | awk '{print $1}'`
 b) SYSFS=$(mount |grep sysfs|awk {'print $3'})
 c) ALSA_DRIVER_VERSION=`cat /proc/asound/version |head -n1|awk {'print $7'} |sed 's/\.$//'`
 d) max_mem=`free | awk 'NR == 2 {fmem=int($2 / 1024); if (fmem < 4000) {print fmem} else {print 4000}}'`
bridge=$(brctl show | awk 'NR==2 {print $1}')
RPMS=$(LANG=C cp -va ${temp_dir_name}/SRPMS/* $kmp_basedir | awk '{print $NF}')
 e) max_mem=`vmstat | awk 'NR == 3 {fmem=int($5 / 1024); if (fmem < 4000) {print fmem} else {print 4000}}'`
 f) line=$(awk '{ print $1 " " $3 " " $2 }' /proc/self/uid_map)

2. Lea el script a continuación y complete los incisos listados: 
  a) Busque errores de sintaxis y elimine los mismos, sin ejecutar 
     efectivamente hasta en tanto no haya eliminado los errores. 
     Para cada error, copie aquí la línea y el error indicado por
     bash. Además indique la resolución. ¿La corrección fue aplicada 
     en la línea indicada por bash? 
     Utilice la opción apropiada de bash para lograrlo. 
  b) Para cada variable del script analice qué sucedería si dicha 
     variable quedase sin definir (es decir, no se le asigna valor 
     en ningún momento). Además indique si, dada la lógica del script,
     es posible que quede sin definir. En caso de ser posible, 
     indique cuál sería el impacto y qué haría para mejorar el script. 
      

#Inicio
#####################
#!/bin/bash

# El siguiente script emite cada 30 segundos un resumen de la 
# cantidad de procesos por usuario, ordenado de menor a mayor. 
# Dicho resumen se emite por pantalla y se guarda en un archivo
# temporal. 

declare -i procs total 
declare -r logfile=$(tempfile)
declare -r instante=$(tempfile)
declare -r temp=$(tempfile)


function total_proc (){ 
  echo $(grep "^$1 " $instante |wc -l)



echo COMIENZO | tee $logfile 

while :; do
     ps -ef --no-headers > $instante 
     total=0 
     date
     for usr in $(cut -f1 -d:  /etc/passwd);do 
	  procs=$(total_proc $usr)
	  if [ $procs -ne 0 ];then 
	    echo ${usr}: $procs
	    let total=total+procs
	  fi 
     done > $temp 
     sort -n -k2 $temp 
     echo "Total de procesos: $total
     sleep 30
done | tee $logfile 

#Limpieza
[[ -f $instante ] && rm $instante 
[[ -f $temp ]] && rm $temp 
echo $logfile debe ser borrado manualmente. 

exit 0
# Fin del script


3. Lea el script a continuación y complete los incisos listados: 
  a) Busque errores de sintaxis y elimine los mismos, sin ejecutar 
     efectivamente hasta en tanto no haya eliminado los errores. 
     Para cada error, copie aquí la línea y el error indicado por
     bash. Además indique la resolución. ¿La corrección fue aplicada 
     en la línea indicada por bash? 
     Utilice la opción apropiada de bash para lograrlo. 
  b) Para cada variable del script analice qué sucedería si dicha 
     variable quedase sin definir (es decir, no se le asigna valor 
     en ningún momento). Además indique si, dada la lógica del script,
     es posible que quede sin definir. En caso de ser posible, 
     indique cuál sería el impacto y qué haría para mejorar el script. 
  c) ¿Qué sucede si no existen archivos jpg en el/los directorios 
     pasados como argumento?¿Cómo podría mejorar esta sección del script?

#Inicio
#####################

# El siguiente script debe ser ejecutado por usuario no 
# administrador. Realiza copias de archivo finalizados en 
# jpg, eliminando esta extensión y reemplazándola por JPG. 
# El script trabaja sobre un conjunto de directorios obtenidos
# como argumento del script. 

#!/bin/bash

function es_root() {
local -u resp

if [[ $(id -u) -eq 0 ]] ;then
    while : ;do 
       echo "DVERTENCIA: ud. es root, realmente desea continuar S/N"
       read resp
       case $resp in:
         S*) return ;
         N*) echo saliendo.. ; exit ;;
       esac 
    done 
 fi 
}

es_root
 
for dir; do
   if [[ -d $dir ]] then 
      cd $dir
      [[ ! -d JPG ]] && mkdir JPG 
      for i in $(ls *jpg);do
	cp -i $i JPG/${i%%jpg}JPG #Expansión de parámetro: remueve jpg del final de $i, agregando JPG.  
      cd $OLDPWD
   fi 
done 
# Fin del script

4. Lea el script a continuación y complete los incisos listados: 
  a) Busque errores de sintaxis y elimine los mismos, sin ejecutar 
     efectivamente hasta en tanto no haya eliminado los errores. 
     Para cada error, copie aquí la línea y el error indicado por
     bash. Además indique la resolución. ¿La corrección fue aplicada 
     en la línea indicada por bash? 
     Utilice la opción apropiada de bash para lograrlo. 
  b) Para cada variable del script analice qué sucedería si dicha 
     variable quedase sin definir (es decir, no se le asigna valor 
     en ningún momento). Además indique si, dada la lógica del script,
     es posible que quede sin definir. En caso de ser posible, 
     indique cuál sería el impacto y qué haría para mejorar el script. 
  c) En el caso de recibir un archivo con el listado de paquetes a evaluar.
     ¿Qué sucede si en dicho archivo hay líneas en blanco? Verifique observando
     la ejecución con la opción -x de bash. ¿Podría mejorar esta situación?
  d) ¿Está funcionando correctamente el script? Observe lo que sucede para un 
     sólo paquete (ejemplo a2ps). ¿Puede detectar cuál es el problema y corregirlo?
     ¿Se trata de un error de sintaxis?

#Inicio
#####################
#!/bin/bash 

# El objetivo del script es encontrar scripts escritos en bash 
# contenidos en paquetes instalados en el sistema. Asumiendo una 
# distribución debian o derivado. Se puede indicar un listado de 
# nombres de paquete, un archivo con una lista de nombres de paquete, 
# o bien si no se proveen argumentos se genera el listado para todos
# los paquetes instalados en el sistema. El listado será emitido por 
# la salida estándar. 

function buscarscript(){
local a
local -i total=0
   
   if ! dpkg -l $1 &> /dev/null; then
     echo "$1 no instalado"
     return 
   fi
   echo $1 
   for archivo in $(dpkg -L $1); do
      a=$(file "$archivo"|grep "Bourne-Again"|cut -f1 -d:)
      if [ -n $a ];then  
	echo "    $a"
        let total++
   done   
   return $total 
}

function todo_sistema(){
local -u resp 
   while :;do
     echo "Se creará un listado para todos los paquetes instalados en el sistema, ¿esta de acuerdo? S/N" 
     read resp 
     case $resp in
        S) return  
        N) echo saliendo...; exit ;; 
     esac
   done  
}

function no_es_root(){
local -u resp 
if [[ $(id -u) -ne 0 ]] ;then
    while : ;do 
       echo "ADVERTENCIA: ud. NO es root, realmente desea continuar? S/N'
       read resp
       case $resp in
         S*) return ;;
         N*) echo saliendo.. ; exit ;;
       esac 
    done 
 fi 
}

declare -i total=0 

no_es_root 

if [[ $# -eq 0 ]];then 
   #Crear listado para todos los paquetes del sistema 
   todo_sistema
   for pkg in $(dpkg -l |awk '$1=="ii" {print $2}'); do
      buscarscript $pkg
      let total=total+$?
   done 
elif [[ -f "$1"]];then
   # Si el primer argumento es un archivo regular, se asume que contiene una
   #lista de nombres de paquetes separada por nueva linea, sin lineas vacías. 
   for pkg in $(cat $1);do
      buscarscript $pkg 
      let total=total+$?
   done 
else
   #Asume que los argumentos son un listado de nombres de paquetes
   for pkg ;do
	buscarscript $pkg
        let total=total+$?
fi 
echo Total de scripts de bash encontrados: $total  
exit 0
# Fin del script
  
5. Lea el script a continuación y complete los incisos listados: 
  a) Busque errores de sintaxis y elimine los mismos, sin ejecutar 
     efectivamente hasta en tanto no haya eliminado los errores. 
     Para cada error, copie aquí la línea y el error indicado por
     bash. Además indique la resolución. ¿La corrección fue aplicada 
     en la línea indicada por bash? 
     Utilice la opción apropiada de bash para lograrlo. 
  b) Para cada variable del script analice qué sucedería si dicha 
     variable quedase sin definir (es decir, no se le asigna valor 
     en ningún momento). Además indique si, dada la lógica del script,
     es posible que quede sin definir. En caso de ser posible, 
     indique cuál sería el impacto y qué haría para mejorar el script. 
  c) ¿Qué sucede con el contenido del nombre, apellido y nota en caso 
     de que el usuario no ingrese valor? ¿Podría mejorar esta situación?
     
  
#Inicio
#####################
#!/bin/bash
# El siguiente script es utilizado por un usuario para ingresar 
# tuplas constituidas de: Nombre, Apellido y nota, correspondientes 
# a un alumno. Basado en cada tupla se emitirá, por la salida 
# estándar, el mismo listado pero con una nota alfabética basada 
# en la nota numérica ingresada. 


function carga_nota(){
  echo -n "Por favor ingrese Nombre: " 
  read nombre
  echo -n "Por favor ingrese Apellido: " 
  read apellido
  while : ;do 
     echo -n "Nota correspondiente a $nombre $apellido: " 
     read nota
     case $nota in 
     [0-9]|10) return ;;
     esac 
  done 
}

function otro_ingreso () {
  local -u resp 
  resp="N"
  while [[ "$resp" != "S" ]];do 	
    echo -n "¿Otro ingreso? S/N": 
    read resp 
    if [[ "$resp" == "N" ]];then 
       return 1
    fi 
  done 	
}

function calificar (){
  echo -n "Nombre: $1, Apellido: $2," 
  case $3 in
    0) echo REPROBADO ;;
    [1-3]) echo INSUFICIENTE ;; 
    4) echo APROBADO ;;
    [5-7]) echo BUENO;;
    [8-9) echo MUY BUENO;;
    10) echo EXCELENTE ;;  
    *) echo NOTA INVALIDA ;;
  esac 
}

declare -u nombre apellido 
declare -i otro=0 cont=0 prom=0
declare nota
declare -r temp=`tempfile || temp=/tmp/listado.$$

while [[ $otro -eq 0 ]]; do
  carga_nota   
  let prom=prom+nota
  let cont++
  calificar $nombre $apellido $nota >> $temp
  otro_ingreso 
  otro=$?
done

let prom=prom/cont
echo PROMEDIO DE NOTAS: $prom  >> $temp 

cat $temp
[[ -f $temp ]] && rm $temp 

exit 0
# Fin del script

6. Sobre el script /usr/sbin/iptables-apply : 
   a) Invocando el script en modo debug (bash -x o -xv), pase como a
   rgumento la opción -h y observe la ejecución. 
   b) Invocando el script en modo debug (bash -x o -xv), pase como a
   rgumento la opción --version y observe la ejecución. 
   c) ¿Qué opciones se ha/n configurado en el script, que permita/n 
   ayudar al correcto funcionamiento y capturar errores comunes?


7. Sobre el script /usr/bin/ldd
   a) Invocando el script en modo debug (bash -x o -xv), pase como 
   argumento la opción --hel y observe la ejecución. 
   b) Invocando el script en modo debug (bash -x o -xv), pase como 
   argumento la opción --ver y observe la ejecución. 

2) Agregue una línea en el crontab de root tal que ejecute todos los días 
cada 10 minutos el script del ejercicio anterior, pero cuya 
salida sea guardada en el archivo /var/log/usuarios_presentes. Dicho archivo 
debe ser acumulativo, esto es, no debe ser sobrescrito con 
cada ejecución. Observe que en este caso ya no será necesario el ciclo 
infinito, pues cron se encarga de la ejecución periódica. ¿Por qué utilizamos
el cron de root y no el de cualquier usuario como en el ejercicio anterior? 


3) Ud es un administrador precavido y sabe que hoy a las 18hs alguien mas va 
a implementar cambios en la configuración del sistema. Por ende decide que un
rato antes de que suceda, quisiera realizar un backup del directorio de 
configuración de sistema en el home de root, sin embargo, le ha surgido una 
cita importante que le impide realizarlo alrededor de las 17hs. Utilice el 
comando at para planificar la tarea. 


4) Indique cómo sería la planificación por crontab para los siguientes casos:
	5.a) Todos los viernes del mes de diciembre
	5.b) Cada 3 días
	5.c) El primer día de cada mes. 
	5.d) De las 18h a las 22hs.
	5.e) En los minutos 0 a 14 y 24 a 35, de las 0hs,7hs y23hs, los días 
	     miércoles.
	5.f) Una vez por año
	 

5) Indique expresiones válidas para indicar a at que comience:
	6.a) dentro de 5 minutos
	6.b) dentro de 3 días 
	6.c) A las 18:23hs 
	6.d) A las 4 de la tarde. 


